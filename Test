import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';

// Mocks
jest.mock('react-i18next', () => ({ useTranslation: () => ({ t: (k) => k }) }));

jest.mock('@atoms/TXInput', () => ({
  TXInput: (props) => {
    // Simple textarea that calls props.onChange with an object matching the component expectation
    return (
      <textarea
        data-testid="remarks"
        name={props.name}
        value={
          // try to surface a sensible string if props.value is an object
          (props.value && (props.value.value || props.value.riskindicatorflag?.value || '')) || ''
        }
        onChange={(e) => props.onChange && props.onChange({ [props.name]: { value: e.target.value } })}
      />
    );
  },
}));

// Simple styled container mock so we can query its presence
jest.mock('./styled', () => ({
  Container: ({ children }) => <div data-testid="container">{children}</div>,
}));

// Mock getList to render a button which will call the passed handler (simulates radio change)
jest.mock('./utils', () => {
  const React = require('react');
  return {
    getList: (item, i, handleRadioGroupOnChange /*, options */) => {
      const id = item && (item.riskindicatorid?.value ?? item.riskindicatorid ?? item) || `idx-${i}`;
      return React.createElement(
        'button',
        {
          'data-testid': `radio-${id}`,
          onClick: () => handleRadioGroupOnChange('false', id), // simulate selecting 'false'
        },
        `toggle-${id}`,
      );
    },
    getRemarksDisabledAndRequiredValue: jest.fn(() => ({})),
  };
});

// We'll capture calls to the actual helper so tests can control its response
const mockGetCodeDecodeList = jest.fn();

jest.mock('@utils/index', () => ({
  isObjectEmpty: jest.fn((v) => Object.keys(v || {}).length === 0),
  getCodeDecodeList: (args) => mockGetCodeDecodeList(args),
  getValueFromPath: (obj, path) => {
    if (obj == null) return undefined;
    if (typeof obj === 'object') return obj[path] ?? obj;
    return obj;
  },
}));

// Component under test
import { TXRiskIndicatorList } from './TXRiskIndicatorList';

describe('TXRiskIndicatorList (unit)', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('returns null (does not render) when value is empty', () => {
    const props = {
      value: {},
      name: 'tx',
      riskIndicatorArrayName: 'riskArray',
      remarksName: 'remarks',
      onChange: jest.fn(),
      path: '',
    };

    render(<TXRiskIndicatorList {...props} />);

    // Component should render nothing when `isObjectEmpty(value)` is true
    expect(screen.queryByTestId('container')).not.toBeInTheDocument();
  });

  test('fetches code list, renders risk items and handles radio & remarks onChange flows', async () => {
    // Prepare mocked code values that the component expects
    const codeValues = [
      { codeValue: 'RI-999', codeValueLocalDescription: 'Manual AML Remarks RI-999 (extra)' },
      { codeValue: 'RI-001', codeValueLocalDescription: 'Indicator 1' },
    ];

    mockGetCodeDecodeList.mockResolvedValue({ RISK_INDICATORS: { codeValues } });

    // Provide a value prop that contains 5 items (the component slices by index and shows the 5th as remarks)
    const value = {
      tx: {
        riskArray: [
          { riskindicatorid: 'RI-001', riskindicatorflag: { value: 'true' } },
          { riskindicatorid: 'RI-002' },
          { riskindicatorid: 'RI-003' },
          { riskindicatorid: 'RI-004' },
          { riskindicatorid: 'RI-999' },
        ],
      },
    };

    const onChange = jest.fn();

    render(
      <TXRiskIndicatorList
        value={value}
        name="tx"
        riskIndicatorArrayName="riskArray"
        remarksName="remarks"
        onChange={onChange}
      />,
    );

    // Wait for the async code list fetch useEffect to run
    await waitFor(() => expect(mockGetCodeDecodeList).toHaveBeenCalled());

    // The mocked getList produces buttons with data-testid `radio-<ID>`; ensure the RI-999 button exists
    const ri999Button = await screen.findByTestId('radio-RI-999');
    expect(ri999Button).toBeInTheDocument();

    // Click the RI-999 radio button which our mock will call handleRadioGroupOnChange('false', 'RI-999')
    fireEvent.click(ri999Button);

    // onChange should have been invoked with updated data
    expect(onChange).toHaveBeenCalled();
    const firstCallData = onChange.mock.calls[0][0];

    // The top-level object should include the risk array
    expect(firstCallData).toHaveProperty('riskArray');

    // Find the modified RI-999 item
    const ri999ItemAfterRadio = firstCallData.riskArray.find((x) => (x.riskindicatorid?.value ?? x.riskindicatorid) === 'RI-999');
    expect(ri999ItemAfterRadio).toBeDefined();

    // The handler sets a nested object for the flag and id
    expect(ri999ItemAfterRadio.riskindicatorflag.value).toBe('false');
    expect(ri999ItemAfterRadio.riskindicatorid.value).toBe('RI-999');

    // When radio changed to false for RI-999, the component sets the top-level remarksName to an empty string
    expect(firstCallData.remarks).toEqual({ value: '' });

    // Now change the remarks textarea (our TXInput mock will call props.onChange with { remarks: { value: '...' } })
    const remarksTextarea = screen.getByTestId('remarks');
    fireEvent.change(remarksTextarea, { target: { value: 'This is a manual remark' } });

    // onChange should be called again with the updated remark merged into the RI-999 item
    expect(onChange).toHaveBeenCalledTimes(2);
    const secondCallData = onChange.mock.calls[1][0];
    const ri999ItemAfterRemarks = secondCallData.riskArray.find((x) => (x.riskindicatorid?.value ?? x.riskindicatorid) === 'RI-999');
    expect(ri999ItemAfterRemarks).toBeDefined();

    // The handleRemarksOnChange merges the provided value into that array item
    expect(ri999ItemAfterRemarks.remarks.value).toBe('This is a manual remark');
  });
});
