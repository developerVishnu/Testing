const convertValue = (value: any): string => {
  if (typeof value?.value === 'boolean') {
    return !!value?.value ? 'Yes' : 'No'
  } else if (typeof value === 'boolean') {
    return !!value ? "Yes" : 'No'
  } else if (typeof value === 'string') {
    return value.split(' ').map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
  }else if(typeof value?.value === 'string'){
    return value?.value?.split(' ').map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
  } if (typeof value?.value === 'number' || typeof value === 'number') {
    return value?.value ?  `${value?.value}` : `${value}`;
  }
  return '';
};

export const isEmptyReturnNull = (value) => {
  return value === null || value === undefined || (typeof value === 'object' && Object.keys(value).length === 0)
    ? null
    : value;
};
export const compareObjects =(obj1, obj2, path = "",defaultLOCData,dataGrid,lcDetailsData) => {
  const differences:any = [];
  let convertingObj1Value = '';
  let convertingObj2Value = '';
  for (const key in obj2) {
    const exceptionFlag = (path?.toLowerCase()?.includes('unformattedvalue') || path?.toLowerCase()?.includes('filimitbookingdetails') || key === 'isChanged' || key === 'previous'
    || path?.toLowerCase()?.includes('cancellationrequest')) ? false : true;

    if (obj2.hasOwnProperty(key) && exceptionFlag) {
      const currentPath = path ? `${path}.${key}` : key;

      if (_.isObject(obj2[key]) && obj1[key]) {
        // Recursive comparison for nested objects
        differences.push(...compareObjects(obj1[key], obj2[key], currentPath,defaultLOCData,dataGrid,lcDetailsData));
      } 
      else if (!_.isEqual(isEmptyReturnNull(obj1[key]), isEmptyReturnNull(obj2[key]))) {
        const decreaseInAmount = currentPath?.includes?.('decreaseInAmount');
        const inAmountChanged = (!!obj1[key] || !!obj2[key]?.currency?.value || !!obj2[key]?.formattedValue?.value);
        const decreaseInAmountFlag = decreaseInAmount ? (decreaseInAmount && inAmountChanged) ? false : true : false;
        convertingObj1Value = convertValue(obj1[key]);
        convertingObj2Value = convertValue(obj2[key]);
        if(!!convertingObj2Value)
        {
          if(currentPath.toLocaleLowerCase().includes('unformattedvalue') || currentPath.toLocaleLowerCase().includes('previous')){
            continue ;
          }
        
          const Obj1CurrencyValue = dataGrid[currentPath.split('.')[0]]?.[currentPath.split('.')[1]]?.['currency']?.['value']  ? dataGrid[currentPath.split('.')[0]]?.[currentPath.split('.')[1]]?.['currency']?.['value'] : undefined;
          const Obj2CurrencyValue = lcDetailsData[currentPath.split('.')[0]]?.[currentPath.split('.')[1]]?.['currency']?.['value']  ? lcDetailsData[currentPath.split('.')[0]]?.[currentPath.split('.')[1]]?.['currency']?.['value'] : undefined;
          let changesByBank = convertingObj2Value || (Obj2CurrencyValue ? `${Obj2CurrencyValue} ${obj2[key]?.value ?? obj2[key]}`: obj2[key]);
          const keyName = currentPath?.split('.')[1];
          changesByBank = CodeDecode(keyName,changesByBank)
          console.log("keyName,changesByBank", convertingObj1Value, path)

          let requestedChange = convertingObj1Value || (Obj1CurrencyValue ? `${Obj1CurrencyValue} ${obj1[key]?.value ?? obj1[key] ?? ''}` : obj1[key])
          requestedChange = requestedChange ? CodeDecode(keyName, requestedChange) : "";
          // If value has changed, add to differences
          const keyArray = currentPath?.split('.')
          const alternateCurrentPath = keyArray.slice(0,-1).join('.')
          differences.push({
            fieldName: defaultLOCData?.label?.[currentPath] ?? defaultLOCData?.label?.[alternateCurrentPath] ?? defaultLOCData?.label?.[currentPath+".value"] ?? currentPath,
            requestedChange,
            changesByBank,
            keyName
          },);
        }
      }
    }
  }
  return differences;
}

const codeDecodeList = {
  'letterOfCreditType': 'LETTEROFCREDIT_TYPE',
  'amendmentType': 'AMENDMENT_TYPE',
  'amendmentChargePayableByCode':'AMENDMENT_CHARGE_PAYABLE_BY',
  'purposeOfMessage':'PURPOSE_OF_MESSAGE',
  'deliveryMode':'LETTEROFCREDIT_SENTBY',
  'signatureVerified':'SIGNATURE_VERIFIED',
  'underwriting':'UNDERWRITING_BY',
  'formOfDocumentaryCredit':'FORMS_OF_LETTEROFCREDIT',
  'applicableRules':'APPLICABLE_RULES',
  'letterOfCreditExpiryPlace':'LETTEROFCREDITEXPIRY_PLACE',
  'letterOfCreditExpiryCountry':'COUNTRIES',
  'availableBy':'AVAILABLE_BY',
  'availableWith':'AVAILABLE_WITH',
  'draftDrawnOnDrawee':'DRAFT_DRAWN_ON',
  'usancePeriod':'USANCE_PERIOD',
  'confirmationInstructions':'CONFIRMATION_INSTRUCTIONS',
  'reimbursementInstruction':'REIMBURSEMENT_INSTRUCTIONS',
  'partialShipment':'PARTIAL_SHIPMENT',
  'transhipment':'TRANSHIPMENT',
  'presentationFrom':'PRESENTATION_FROM',
  'incotermYear':'INCOTERM_YEAR',
  'incoterm':'INCOTERM',
  'modeOfShipment':'MODES_OF_SHIPMENT',
  'insurancePaidBy':'INSURANCE_PAID_BY',
  'insuranceCover':'INSURANCE_COVER',
  'clientSpecifiedCharges':'CHARGES',
  'advisingCharges':'CHARGED_PARTY_EXCLUSION',
  'confirmationCharges':'CHARGED_PARTY_EXCLUSION',
  'reimbursementAndRemittanceCharges':'CHARGED_PARTY_EXCLUSION',
  'discrepancyCharges':'CHARGED_PARTY_EXCLUSION',
  'reimbursingBankCharges':'REIMBURSING_BANK_CHARGES',
  'discountingInterest':'DISCOUNTING_INTEREST'}
export const CodeDecode = (molecule,val):any => {
  if(!(molecule in codeDecodeList) && !val)
  return val
  else {
    const key = codeDecodeList[molecule]+'_en';
    const modKey = 'SC_*_'+key
    let sessionObj:any = sessionStorage.getItem(key) || sessionStorage.getItem(modKey);
    sessionObj = JSON.parse(sessionObj);
    if(!!sessionObj){
      const code = sessionObj[codeDecodeList[molecule]]?.codeValues?.filter((element) => typeof val === 'string' && element?.codeValue?.value === val || typeof val === 'object' && element?.codeValue?.value === val?.value)
      if(!!code){
        if(!!code[0]?.codeValue?.value && !!code[0]?.codeValueLocalDescription?.value)
        return code[0]?.codeValue?.value+" - "+code[0]?.codeValueLocalDescription?.value
      }
      if(molecule === 'letterOfCreditExpiryCountry'){
        const codeAnother = sessionObj[codeDecodeList['TX_BOOKING_LOCATIONS']]?.codeValues?.filter((element) => typeof val === 'string' && element?.codeValue?.value === val || typeof val === 'object' && element?.codeValue?.value === val?.value)
        if(!!codeAnother){
          if(!!codeAnother[0]?.codeValue?.value && !!codeAnother[0]?.codeValueLocalDescription?.value)
          return codeAnother[0]?.codeValue?.value+" - "+codeAnother[0]?.codeValueLocalDescription?.value
        }
      }
    }
  }
  return val; 
}
