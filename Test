import {
  bind,
  Interceptor,
  InvocationContext,
  InvocationResult,
  Provider,
  ValueOrPromise,
  ContextTags,
} from '@loopback/context';
import {RestBindings} from '@loopback/rest';
import {JWTUtil, ProjectConfig} from '@tradexpress/core-web-utils';
import { AuthUtil } from '@tradexpress/web-backend-utils';
import {InterceptorBindings} from '../keys';
 
@bind({tags: {[ContextTags.KEY]: InterceptorBindings.AUTHORIZATION_KEY.key}})
export class AuthorizationInterceptor implements Provider<Interceptor> {
  static readonly BINDING_KEY = `interceptors.${AuthorizationInterceptor.name}`;
 
  value() {
    return this.intercept.bind(this);
  }
 
  async intercept(
    invocationCtx: InvocationContext,
    next: () => ValueOrPromise<InvocationResult>,
  ) {
    try {
      const httpReq: any = await invocationCtx.get(RestBindings.Http.REQUEST, {
        optional: true,
      });
      
      if (!!ProjectConfig
        && !!ProjectConfig.configs
        && ProjectConfig.configs.disableAuthenticationRestrictions === true
      ) {
        return await next();
      }
 
      if (httpReq.headers.authorization) {
        let token = httpReq.headers.authorization.replace('Bearer', '').trim();
        const isValidToken = await AuthUtil.isValidToken(ProjectConfig.configs, token);
        if (!isValidToken) {
          throw Object.assign(new Error(`Invalid authorization token`), {
            code: 'AUTH_TOKEN_INVALID',
            statusCode: 401,
          });
        }
      } else {
        throw Object.assign(new Error(`Authorization token is missing`), {
          code: 'AUTH_TOKEN_NOT_FOUND',
          statusCode: 401,
        });
      }
      return await next();
    } catch (err) {
      throw err;
    }
  }
}
