import {expect} from '@loopback/testlab';
import {
  FindRoute,
  InvokeMethod,
  ParseParams,
  Reject,
  RequestContext,
  RestBindings,
  Send,
} from '@loopback/rest';
import {MySequence} from '../path-to-your-sequence'; // Update with the actual path

describe('MySequence', () => {
  let sequence: MySequence;
  let findRoute: FindRoute;
  let parseParams: ParseParams;
  let invoke: InvokeMethod;
  let send: Send;
  let reject: Reject;

  beforeEach(() => {
    findRoute = jest.fn().mockReturnValue(() => {});
    parseParams = jest.fn().mockResolvedValue([]);
    invoke = jest.fn().mockResolvedValue('test-result');
    send = jest.fn();
    reject = jest.fn();

    sequence = new MySequence(findRoute, parseParams, invoke, send, reject);
  });

  it('handles a successful request', async () => {
    const request = {method: 'GET', url: '/test'} as any;
    const response = {} as any;

    const context = {
      request,
      response,
    } as RequestContext;

    // Execute the sequence
    await sequence.handle(context);

    // Assert the flow
    expect(findRoute).toHaveBeenCalledWith(request);
    expect(parseParams).toHaveBeenCalled();
    expect(invoke).toHaveBeenCalled();
    expect(send).toHaveBeenCalledWith(response, 'test-result');
  });

  it('handles errors by calling reject', async () => {
    const request = {method: 'GET', url: '/test'} as any;
    const response = {} as any;

    const context = {
      request,
      response,
    } as RequestContext;

    // Mock invoke to throw an error
    const error = new Error('test-error');
    invoke = jest.fn().mockRejectedValue(error);
    sequence = new MySequence(findRoute, parseParams, invoke, send, reject);

    // Execute the sequence
    await sequence.handle(context);

    // Assert error handling
    expect(reject).toHaveBeenCalledWith(context, error);
  });
});
